name: CI/CD to EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:


env:
  AWS_REGION: eu-north-1
  IMAGE_TAG: ${{ github.sha }}

concurrency:
  group: cicd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    name: Build & Push Images to ECR
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ vars.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Compute ECR registry
      run: echo "ECR_REGISTRY=${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # ---- Build & push services (latest + SHA) ----
    - name: Build & push Auth Service
      uses: docker/build-push-action@v5
      with:
        context: ./services/auth-service
        file: ./services/auth-service/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/brainlens-auth:latest
          ${{ env.ECR_REGISTRY }}/brainlens-auth:${{ env.IMAGE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build & push Image Service
      uses: docker/build-push-action@v5
      with:
        context: ./services/image-service
        file: ./services/image-service/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/brainlens-image:latest
          ${{ env.ECR_REGISTRY }}/brainlens-image:${{ env.IMAGE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build & push Annotation Service
      uses: docker/build-push-action@v5
      with:
        context: ./services/annotation-service
        file: ./services/annotation-service/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/brainlens-annotation:latest
          ${{ env.ECR_REGISTRY }}/brainlens-annotation:${{ env.IMAGE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build & push Colab Service
      uses: docker/build-push-action@v5
      with:
        context: ./services/colab-service
        file: ./services/colab-service/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/brainlens-colab:latest
          ${{ env.ECR_REGISTRY }}/brainlens-colab:${{ env.IMAGE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build & push Frontend Service
      uses: docker/build-push-action@v5
      with:
        context: ./services/frontend-service
        file: ./services/frontend-service/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/brainlens-frontend:latest
          ${{ env.ECR_REGISTRY }}/brainlens-frontend:${{ env.IMAGE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Verify ECR images
      run: |
        echo "üîç Verifying ECR images..."
        for repo in brainlens-auth brainlens-image brainlens-annotation brainlens-colab brainlens-frontend; do
          aws ecr describe-images --repository-name $repo --image-ids imageTag=${IMAGE_TAG} --region $AWS_REGION >/dev/null
          echo "‚úÖ $repo:${IMAGE_TAG}"
        done

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ vars.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set EKS context
      run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name brainlens-eks

    - name: Compute ECR registry
      run: echo "ECR_REGISTRY=${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_ENV

    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes | cat

    - name: Create/Update imagePullSecret for ECR
      run: |
        kubectl create namespace brainlens --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret docker-registry ecr-pull-secret \
          --namespace brainlens \
          --docker-server=${{ env.ECR_REGISTRY }} \
          --docker-username=AWS \
          --docker-password="$(aws ecr get-login-password --region ${{ env.AWS_REGION }})" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Apply base config (namespace/configmap/network)
      run: |
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml || true
        kubectl apply -f k8s/network-policies.yaml || true

    - name: Apply application secrets (MongoDB/JWT)
      env:
        MONGODB_URI: ${{ secrets.MONGODB_URI }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
      run: |
        if [ -z "$MONGODB_URI" ]; then echo "Missing secret MONGODB_URI"; exit 1; fi
        if [ -z "$JWT_SECRET" ]; then echo "Missing secret JWT_SECRET"; exit 1; fi
        kubectl -n brainlens create secret generic brainlens-secrets \
          --from-literal=mongo-connection-string="$MONGODB_URI" \
          --from-literal=jwt-secret="$JWT_SECRET" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Replace placeholders (registry + tag) in manifests
      run: |
        sed -i "s|{{ECR_REGISTRY}}|${{ env.ECR_REGISTRY }}|g" k8s/*.yaml
        sed -i "s|{{IMAGE_TAG}}|${{ env.IMAGE_TAG }}|g" k8s/*.yaml

    - name: Ensure deployments reference imagePullSecret
      run: |
        for app in auth-service image-service annotation-service colab-service frontend-service; do
          kubectl -n brainlens patch deployment/$app --type='merge' -p '{
            "spec":{"template":{"spec":{"imagePullSecrets":[{"name":"ecr-pull-secret"}]}}}
          }' || true
        done

    - name: Deploy workloads
      run: |
        # Aplica manifests (ya con ECR_REGISTRY e IMAGE_TAG)
        for f in k8s/auth-service.yaml k8s/image-service.yaml k8s/annotation-service.yaml k8s/colab-service.yaml k8s/frontend-service.yaml; do
          kubectl apply -f "$f"
        done
        # Ingress al final
        kubectl apply -f k8s/ingress.yaml

    - name: Rollout status
      run: |
        for app in auth-service image-service annotation-service colab-service frontend-service; do
          echo "‚è≥ Waiting rollout: $app"
          kubectl -n brainlens rollout status deployment/$app --timeout=600s
        done

    - name: Show deployed images
      run: |
        for app in auth-service image-service annotation-service colab-service frontend-service; do
          echo "---- $app ----"
          kubectl -n brainlens get deploy $app -o=jsonpath='{range .spec.template.spec.containers[*]}{.name}{" -> "}{.image}{"\n"}{end}'; echo
        done

    - name: Run health checks
      run: |
        echo "üîç Health checks..."
        sleep 30
        AUTH_POD=$(kubectl get pod -n brainlens -l app=auth-service -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n brainlens "$AUTH_POD" -- curl -sf http://localhost:8001/api/v1/auth/health
        IMG_POD=$(kubectl get pod -n brainlens -l app=image-service -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n brainlens "$IMG_POD" -- curl -sf http://localhost:8002/api/v1/images/health
        ANN_POD=$(kubectl get pod -n brainlens -l app=annotation-service -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n brainlens "$ANN_POD" -- curl -sf http://localhost:8003/api/v1/annotations/health
        COLAB_POD=$(kubectl get pod -n brainlens -l app=colab-service -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n brainlens "$COLAB_POD" -- curl -sf http://localhost:8004/api/v1/colab/health
        echo "‚úÖ All services healthy"

    - name: Post-deploy status
      if: always()
      run: |
        echo "üìä Resources:"
        kubectl get pods -n brainlens | cat
        kubectl get svc -n brainlens | cat
        kubectl get ingress -n brainlens | cat
        LB_URL=$(kubectl get ingress brainlens-ingress -n brainlens -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
        if [ -n "$LB_URL" ]; then
          echo "üåç Application: http://$LB_URL"
        else
          echo "‚è≥ LB URL a√∫n no disponible. Revisa m√°s tarde:"
          echo "kubectl get ingress brainlens-ingress -n brainlens"
        fi
